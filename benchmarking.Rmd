---
title: "Transposable Elements: Types, Characterization, Identification, and Annotation"
author: "Banguket Nina(2366065)"
date: "2025-10-23"
output:
  pdf_document:
    toc: false
fontsize: 11pt
geometry: margin=1in
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
setwd("~/Desktop/Thesis/Benchmarking")
```


```{r include=FALSE}
library(rtracklayer)
library(Biostrings)
library(dplyr)
library(tidyr)
library(knitr)
library(kableExtra)
library(tidyverse)
library(patchwork)
library(stringr)
```

```{r data import, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
#Importing standardised drosophila TE annotation from EDTA
droso_edta_TEonly <- read.csv("~/Desktop/Thesis/Benchmarking/benchmarking_EDA/droso_edta_standardised.csv")

#Importing standardised Drosophila M annotation from EarlGrey
droso_earlG_TEonly <- read.csv("~/Desktop/Thesis/Benchmarking/benchmarking_EDA/droso_earlG_standardised.csv")
```


After filtering, EDTA dataset retained 12 unique TE types while Earl Grey has 18 unique TE types.

## Data Exploration

From here were are working only with the filtered  and standardised dataset.

### Comparing the average width and score
The score represented in both tables is the Smith-Waterman score. 
Smith-Waterman algorithm :It’s a local alignment algorithm, meaning it finds
the best matching subsequences between two sequences (rather than
forcing alignment across their entire lengths).The genomic sequence
fragment (a candidate transposable element) is aligned with a known TE
consensus/reference from the repeat library. The algorithm computes a
dynamic-programming matrix of match/mismatch/gap scores ussing affine gap scoring metthod and finds the highest‐scoring local alignment. A higher average score suggests better local alignment performed by pipeline.
Better local alignment ensures that genomic fragments are accurately matched to the correct TE family, reducing misclassification and false positives. It also improves the reliability of TE boundaries and overall annotation quality.



The width of a transposable element represents the length of its annotated genomic interval.It provides a simple indication of whether most TEs in the dataset are intact (longer widths) or truncated/fragmented (shorter widths). The average TE width therefore offers a simple way to compare pipelines, with larger mean widths suggesting that a tool identifies more complete TE structures.


```{r echo=FALSE}
# Compute summary values
avg_width_edta   <- round(mean(droso_edta_TEonly$width,  na.rm = TRUE), 2)
avg_width_earlG  <- round(mean(droso_earlG_TEonly$width, na.rm = TRUE), 2)

avg_score_edta   <- round(mean(droso_edta_TEonly$score,  na.rm = TRUE), 2)
avg_score_earlG  <- round(mean(droso_earlG_TEonly$score, na.rm = TRUE), 2)

# Construct table
comparison_table <- data.frame(
  Dataset = c("EDTA TE-only", "EarlGrey TE-only"),
  Avg_Width = c(avg_width_edta, avg_width_earlG),
  Avg_Score = c(avg_score_edta, avg_score_earlG)
)

# Render kable
knitr::kable(
  comparison_table,
  caption = "Comparison of Average Width and Average Score Between EDTA and EarlGrey TE-only Datasets"
)

```

The results from the table suggest that EDTA produces more intact TEs with better scores.

### TE Classificaiton Level summaries


```{r EDTA classification, include=FALSE}
edta2 <- droso_edta_TEonly 

# Earl grey classification, include=FALSE}
earl2 <- droso_earlG_TEonly 

```

```{r Summary kable EDTA, echo=FALSE}
edta_table <- edta2 %>%
  count(class, order, superfamily, sort = TRUE)

kable(edta_table, 
      caption = "EDTA: TE counts by class, order, and superfamily",
      align = "lrr") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

```



```{r Earl Grey summmary kable, echo=FALSE}
earl_table <- earl2 %>%
  count(class, order, superfamily, sort = TRUE)

kable(earl_table,
      caption = "Earl Grey: TE counts by class, order, and superfamily",
      align = "lrr") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

```



```{r}
library(patchwork)

kable(edta_table, caption = "EDTA")  
kable(earl_table, caption = "Earl Grey")

```

### Class -Level Statistics

```{r echo=FALSE}
edta_class_stats <- edta2 %>%
  count(class, sort = TRUE) %>%
  mutate(proportion = round(n / sum(n), 4))

kable(edta_class_stats,
      caption = "EDTA: Class-level TE statistics",
      align = "lrr") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped", "hover"))


```




```{r echo=FALSE}
earl_class_stats <- earl2 %>%
  count(class, sort = TRUE) %>%
  mutate(prop = round(n / sum(n), 4))

kable(earl_class_stats,
      caption = "Earl Grey: Class-level TE statistics",
      align = "lrr") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped", "hover"))

earl_class_stats
```



```{r echo=FALSE}
combined_class <- bind_rows(
  edta_class_stats %>% mutate(dataset = "EDTA"),
  earl_class_stats %>% mutate(dataset = "Earl Grey")
)

ggplot(combined_class,
       aes(x = class, y = n, fill = dataset)) +
  geom_col(position = "dodge") +
  coord_flip() +
  labs(
    title = "Comparison of Class-level TE Counts: EDTA vs Earl Grey",
    x = "Class",
    y = "Count"
  ) +
  theme_bw()

```


### order-Level Statistics

```{r echo=FALSE}

edta_order_stats <- edta2 %>%
  count(order, sort = TRUE) %>%
  mutate(prop = round(n / sum(n), 4))

kable(edta_order_stats,
      caption = "EDTA: Order-level TE statistics",
      align = "lrr") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped", "hover"))

```

```{r echo=FALSE}
earl_order_stats <- earl2 %>%
  count(order, sort = TRUE) %>%
  mutate(prop = round(n / sum(n), 4))

kable(earl_order_stats,
      caption = "Earl Grey: Order-level TE statistics",
      align = "lrr") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped", "hover"))

```





```{r echo=FALSE}
ggplot(edta_order_stats,
       aes(x = fct_reorder(order, n), y = n, fill = order)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "EDTA – TE Count by Order",
    x = "Order",
    y = "Count"
  ) +
  theme_bw() +
  theme(legend.position = "none")

```

```{r echo=FALSE}
ggplot(earl_order_stats,
       aes(x = fct_reorder(order, n), y = n, fill = order)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Earl Grey – TE Count by Order",
    x = "Order",
    y = "Count"
  ) +
  theme_bw() +
  theme(legend.position = "none")

```




```{r echo=FALSE}
combined_order <- bind_rows(
  edta_order_stats %>% mutate(dataset = "EDTA"),
  earl_order_stats %>% mutate(dataset = "Earl Grey")
)

ggplot(combined_order,
       aes(x = order, y = n, fill = dataset)) +
  geom_col(position = "dodge") +
  coord_flip() +
  labs(
    x = "Order",
    y = "Count"
  ) +
  theme_bw()

```
### Superfamily Level Statistics

```{r echo=FALSE}

edta_superfamily_stats <- edta2 %>%
  group_by(class, order, superfamily) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(desc(n)) %>%
  mutate(prop = round(n / sum(n), 4))

kable(edta_superfamily_stats,
      caption = "EDTA: Superfamily-level TE statistics with Class and Order",
      align = "lrrr") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped", "hover"))


```



```{r echo=FALSE}
earl_superfamily_stats <- earl2 %>%
  group_by(class, order, superfamily) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(desc(n)) %>%
  mutate(prop = round(n / sum(n), 4))

kable(earl_superfamily_stats,
      caption = "Earl Grey: Superfamily-level TE statistics with Class and Order",
      align = "lrrr") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped", "hover"))

```


```{r echo=FALSE}
edta_superfamily_top15 <- edta_superfamily_stats %>%
  slice_max(n, n = 15)

p_ed <- ggplot(edta_superfamily_top15,
       aes(x = fct_reorder(superfamily, n), y = n, fill = class)) +
  geom_col() +
  coord_flip() +
  labs(
    x = "Superfamily",
    y = "Count"
  ) +
  theme_bw()


p_ed
```

```{r echo=FALSE}
earl_superfamily_top15 <- earl_superfamily_stats %>%
  slice_max(n, n = 15)

p_eg <- ggplot(earl_superfamily_top15,
       aes(x = fct_reorder(superfamily, n), y = n, fill = class)) +
  geom_col() +
  coord_flip() +
  labs(
    x = "Superfamily",
    y = "Count"
  ) +
  theme_bw()


p_eg
```


```{r}

p_ed 
p_eg

```

### Width Distribution


**EDTA**
```{r echo=FALSE}
ggplot(edta2, aes(x = width)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "black") +
  labs(
    title = "EDTA – TE Width Distribution",
    x = "Width (bp)",
    y = "Count"
  ) +
  theme_bw()

```

The plot is extremely right skewed with most TEs with width ~1000bp
Log-transformation due to skewed nature of distribution

```{r echo=FALSE}
ggplot(edta2, aes(x = width)) +
  geom_histogram(bins = 50, fill = "darkgreen", color = "black") +
  scale_x_log10() +
  labs(
    title = "EDTA – TE Width Distribution (log10 scale)",
    x = "Width (bp, log10)",
    y = "Count"
  ) +
  theme_bw()

```

The TE width distribution reveals clear biological structure, with distinct peaks around 150–300 bp and 400–2000 bp.
Longer elements such as LTRs and full-length LINEs form a tapering tail extending up to ~10 kb.

```{r echo=FALSE}
ggplot(edta2, aes(x = width, fill = class)) +
  geom_histogram(bins = 50, alpha = 0.6, position = "identity") +
  scale_x_log10() +
  labs(
    title = "EDTA – Width Distribution by Class",
    x = "Width (bp, log10)",
    y = "Count",
    fill = "Class"
  ) +
  theme_bw()

```
```{r}
ggplot(edta2, aes(x = width, fill = class, colour = class)) +
  geom_density(alpha = 0.25, adjust = 1.1) +
  scale_x_log10() +
  labs(
    x = "Width (bp, log10)",
    y = "Density",
    fill = "Class",
    colour = "Class"
  ) +
  theme_bw()

```


Retrotransposons span a broad width range, with most elements between ~150 bp and several kilobases, reflecting the diversity of LINEs and LTRs.
DNA transposons are concentrated at shorter lengths (~150–400 bp), forming a sharp peak consistent with compact TIR-based elements, while Unknowns appear only at low frequency across the range.

```{r echo=FALSE}
ggplot(edta2, aes(x = order, y = width, fill = order)) +
  geom_violin() +
  scale_y_log10() +
  labs(
    title = "EDTA – Width by TE Order",
    x = "Order",
    y = "Width (bp, log10)"
  ) +
  theme_bw() +
  theme(legend.position = "none")

```

LINE and LTR elements show broad and highly skewed length distributions, with many truncated copies and a long tail of full-length elements extending into the kilobase range.
DNA transposons and MITEs are tightly clustered at shorter lengths (typically 100–500 bp), reflecting their compact TIR-based structure, while DNAnona occupies an intermediate range with moderate variability.

**Earl Grey**
```{r echo=FALSE}
ggplot(earl2, aes(x = width)) +
  geom_histogram(bins = 50, fill = "purple", color = "black") +
  labs(
    title = "Earl Grey – TE Width Distribution",
    x = "Width (bp)",
    y = "Count"
  ) +
  theme_bw()

```

```{r echo=FALSE}
ggplot(earl2, aes(x = width)) +
  geom_histogram(bins = 50, fill = "orange", color = "black") +
  scale_x_log10() +
  labs(
    title = "Earl Grey – TE Width Distribution (log10 scale)",
    x = "Width (bp, log10)",
    y = "Count"
  ) +
  theme_bw()

```

The Earl Grey width distribution shows a broad, smooth peak spanning roughly 50–3000 bp, indicating a mixture of short DNA transposons and longer LTR/LINE elements.
The long right tail up to ~10–20 kb reflects full-length retrotransposons, while the leftmost bins capture very short fragments and potential truncated elements.


```{r}
ggplot(earl2, aes(x = width, fill = class)) +
  geom_histogram(bins = 50, alpha = 0.6, position = "identity") +
  scale_x_log10() +
  labs(
    title = "Earl Grey – Width Distribution by Class",
    x = "Width (bp, log10)",
    y = "Count",
    fill = "Class"
  ) +
  theme_bw()

```

```{r}
ggplot(earl2, aes(x = width, fill = class, colour = class)) +
  geom_density(alpha = 0.25, adjust = 1.1) +
  scale_x_log10() +
  labs(
    x = "Width (bp, log10)",
    y = "Density",
    fill = "Class",
    colour = "Class"
  ) +
  theme_bw()


```


```{r}
ggplot(earl2, aes(x = order, y = width, fill = order)) +
  geom_violin() +
  scale_y_log10() +
  labs(
    title = "Earl Grey – Width by TE Order",
    x = "Order",
    y = "Width (bp, log10)"
  ) +
  theme_bw() +
  theme(legend.position = "none")

```

```{r}
library(patchwork)

# Common x-axis range (log scale requires positive widths)
xmin <- min(c(edta2$width, earl2$width), na.rm = TRUE)
xmax <- max(c(edta2$width, earl2$width), na.rm = TRUE)
xmin <- max(xmin, 1)  # protect log scale

common_x <- c(xmin, xmax)

p_edta_den <- ggplot(edta2, aes(x = width, fill = class, colour = class)) +
  geom_density(alpha = 0.25, adjust = 1.1) +
  scale_x_log10(limits = common_x) +
  labs(
    x = "Width (bp, log10)",
    y = "Density",
    fill = "Class",
    colour = "Class"
  ) +
  theme_bw()

p_earl_den <- ggplot(earl2, aes(x = width, fill = class, colour = class)) +
  geom_density(alpha = 0.25, adjust = 1.1) +
  scale_x_log10(limits = common_x) +
  labs(
    x = "Width (bp, log10)",
    y = "Density",
    fill = "Class",
    colour = "Class"
  ) +
  theme_bw()

# Side-by-side comparison
p_edta_den / p_earl_den

```

```{r}
library(patchwork)

xmin <- max(min(c(edta2$width, earl2$width), na.rm = TRUE), 1)
xmax <- max(c(edta2$width, earl2$width), na.rm = TRUE)

# Build plots first
p_edta_den <- ggplot(edta2, aes(x = width, fill = class, colour = class)) +
  geom_density(alpha = 0.25, adjust = 1.1) +
  scale_x_log10(limits = c(xmin, xmax)) +
  labs(x = "Width (bp, log10)", y = "Density") +
  theme_bw()

p_earl_den <- ggplot(earl2, aes(x = width, fill = class, colour = class)) +
  geom_density(alpha = 0.25, adjust = 1.1) +
  scale_x_log10(limits = c(xmin, xmax)) +
  labs(x = "Width (bp, log10)", y = "Density") +
  theme_bw()

# Extract maximum y-value across both plots
ymax <- max(
  ggplot_build(p_edta_den)$layout$panel_params[[1]]$y.range,
  ggplot_build(p_earl_den)$layout$panel_params[[1]]$y.range
)

# Apply common y-axis limits
p_edta_den2 <- p_edta_den + scale_y_continuous(limits = c(0, ymax))
p_earl_den2 <- p_earl_den + scale_y_continuous(limits = c(0, ymax))

p_edta_den2 / p_earl_den2

```

```{r}
ggplot(edta2, aes(x = width, colour = class)) +
  geom_freqpoly(bins = 60, linewidth = 1) +
  scale_x_log10() +
  labs(
    x = "Width (bp, log10)",
    y = "Count",
    colour = "Class"
  ) +
  theme_bw()

```

```{r}
library(dplyr)

combined_width <- bind_rows(
  edta2 %>% mutate(pipeline = "EDTA"),
  earl2 %>% mutate(pipeline = "EarlGrey")
)

ggplot(combined_width, aes(x = width, colour = class, linetype = pipeline)) +
  geom_freqpoly(bins = 60, linewidth = 1) +
  scale_x_log10() +
  labs(
    x = "Width (bp, log10)",
    y = "Count",
    colour = "Class",
    linetype = NULL
  ) +
  theme_bw()

```


```{r}
combined <- bind_rows(
  edta2 %>% mutate(pipeline = "EDTA"),
  earl2 %>% mutate(pipeline = "EarlGrey")
)

ymin <- max(min(combined$width, na.rm=TRUE), 1)
ymax <- max(combined$width, na.rm=TRUE)

ggplot(combined, aes(x = order, y = width, fill = pipeline)) +
  geom_boxplot(outlier.alpha = 0.2, position = position_dodge(width = 0.8)) +
  scale_y_log10(limits = c(ymin, ymax)) +
  labs(x = "Order", y = "Width (bp, log10)", fill = NULL) +
  theme_bw()

```

```{r}
# Common y-axis limits (avoid zeros/negative for log scale)
ymin <- min(c(edta2$width, earl2$width), na.rm = TRUE)
ymax <- max(c(edta2$width, earl2$width), na.rm = TRUE)

# If there are any widths <= 0 (shouldn't happen, but safe)
ymin <- max(ymin, 1)

common_y <- c(ymin, ymax)

p_edta_order <- ggplot(edta2, aes(x = order, y = width, fill = order)) +
  geom_violin() +
  scale_y_log10(limits = common_y) +
  labs(
    x = "Order",
    y = "Width (bp, log10)"
  ) +
  theme_bw() +
  theme(legend.position = "none")

p_earl_order <- ggplot(earl2, aes(x = order, y = width, fill = order)) +
  geom_violin() +
  scale_y_log10(limits = common_y) +
  labs(
    x = "Order",
    y = "Width (bp, log10)"
  ) +
  theme_bw() +
  theme(legend.position = "none")

p_edta_order
p_earl_order

```


```{r}
ggplot(edta2, aes(x = order, y = width, fill = order)) +
  geom_violin(trim = TRUE) +
  geom_boxplot(width = 0.15, outlier.size = 0.3, alpha = 0.6) +
  scale_y_log10(limits = common_y) +
  labs(x = "Order", y = "Width (bp, log10)") +
  theme_bw() +
  theme(legend.position = "none")

```



LINE and LTR elements exhibit broad and highly variable length distributions, with long tails extending into the kilobase range, suggesting frequent truncation and the presence of full-length retrotransposons.
DNA transposons show a narrower and shorter size range, while the ‘Unknown’ group spans mixed lengths, likely representing fragments or unclassified remnants.


### TE Age analysis


TE age can be inferred from the degree of sequence similarity between individual copies and their corresponding consensus sequence. Each TE family is represented by such a consensus, which reflects an approximation of the ancestral state of that element. When a TE copy inserts into the genome, it typically matches the consensus very closely because it has undergone little to no mutational change at the moment of insertion. As time passes, substitutions and small-scale mutations accumulate independently within each copy. This gradual accumulation of mutations reduces sequence identity relative to the consensus, making identity a practical proxy for TE age. In this context, high identity indicates recently inserted, young TE copies, whereas lower identity suggests older elements that have persisted in the genome for much longer.

Structural and homology-based TE detection methods capture different parts of this age spectrum. Structure-based methods, such as those used within EDTA, recognise TEs by their architectural signatures—features like flanking long terminal repeats, terminal inverted repeats, characteristic motifs, or target site duplications. These structural hallmarks decay over evolutionary time, meaning that only intact or nearly intact TEs will still possess the features required for structural detection. As a result, structure-based predictions predominantly identify the youngest and most complete elements, which are expected to have high identity values because they have accumulated relatively few mutations since insertion. These younger intact copies preserve clearer LTR boundaries, characteristic motifs, and well-defined target site duplications, making them detectable by structural algorithms.

In contrast, homology-based TE identification does not rely on preserved structural signatures. Instead, it detects TEs by sequence similarity to known TE families, enabling recognition of both intact and heavily degraded copies. This means homology-based searches recover not only full-length elements but also the vast population of fragmented, truncated, or otherwise eroded TE remnants that constitute the majority of TE-derived genomic content. Because these degraded elements have lost their original structural features through mutation, deletion, and recombination, they cannot be detected de novo and only become visible during the homology-based genome-wide masking stage. Consequently, homology-based identification spans a far broader age range and dominates the pool of older, low-identity TE copies.

The LTR retrotransposon content of the dataset illustrates this relationship clearly. Only a very small minority of LTR retrotransposons remain sufficiently intact to be recovered through structure-based detection. Most LTR-derived sequences persist as incomplete internal regions, truncated fragments, or solo-LTRs produced by recombination events that excise internal domains. These sequences lack the paired LTRs or other architectural features required for structural recognition. As a result, although EDTA’s structural module generates the initial set of full-length LTR exemplars, the vast majority of LTR annotations ultimately arise from homology-based expansion of those exemplars during genome masking. This explains why most LTR retrotransposons in the final dataset were identified through homology rather than de novo structural discovery, despite the initial library being constructed from structural detections.

Taken together, these considerations show why TE identity in EDTA and KIMURA80 divergence in Earl Grey serve as meaningful age indicators, and why structural versus homology-based detection produces characteristic patterns in age distributions.Young, intact TEs display high identity or low divergence, and are typically associated with structural detection, whereas older, degraded copies form the broader, lower-identity or higher-divergence distribution that overwhelmingly reflects homology-based recovery.

```{r}
edta_homol <- edta2 %>% 
  filter(method == "homology")

edta_struct <- edta2 %>%
  filter(method != "homology")

```

```{r echo=FALSE}
table(edta2$method)

```


PS: I am yet to differentiate homology-based and structure-based in Earl Grey

**Part 1: Homology-Based Identity**

```{r echo=FALSE}
ggplot(edta_homol, aes(x = identity)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "black") +
  labs(
    title = "EDTA – Identity Distribution (Homology-Based TEs)",
    x = "Identity to Consensus",
    y = "Count"
  ) +
  theme_bw()


```

```{r echo=FALSE}
ggplot(edta_homol, aes(x = class, y = identity, fill = class)) +
  geom_boxplot() +
  coord_flip() +
  labs(
    title = "EDTA – Identity by Class (Homology-Based)",
    x = "Class",
    y = "Identity"
  ) +
  theme_bw()

```

```{r include=FALSE}
edta_identity_summary <- edta_homol %>%
  summarise(
    mean_identity = mean(identity, na.rm = TRUE),
    median_identity = median(identity, na.rm = TRUE),
    sd_identity = sd(identity, na.rm = TRUE),
    n = n()
  )

edta_identity_by_class <- edta_homol %>%
  group_by(class) %>%
  summarise(
    mean_identity = mean(identity, na.rm = TRUE),
    median_identity = median(identity, na.rm = TRUE),
    sd_identity = sd(identity, na.rm = TRUE),
    n = n()
  )

```

```{r echo=FALSE}
edta_identity_by_class
```

**Structure-Based TE identity analysis**


```{r echo=FALSE}
ggplot(edta_struct, aes(x = ltr_identity)) +
  geom_histogram(bins = 40, fill = "goldenrod", color = "black") +
  labs(
    title = "EDTA Identity (Structure-Based LTRs)",
    x = "LTR–LTR Identity",
    y = "Count"
  ) +
  theme_bw()

```


```{r echo=FALSE}
ggplot(edta_struct, aes(x = ltr_identity)) +
  geom_histogram(bins = 40, fill = "goldenrod", color = "black") +
  labs(
    title = "EDTA Identity (Structure-Based LTRs)",
    x = "LTR–LTR Identity",
    y = "Count"
  ) +
  theme_bw()

```

```{r echo=FALSE}
edta_ltr_identity_summary <- edta_struct %>%
  summarise(
    mean_ltr_identity = mean(ltr_identity, na.rm = TRUE),
    median_ltr_identity = median(ltr_identity, na.rm = TRUE),
    sd_ltr_identity = sd(ltr_identity, na.rm = TRUE),
    n = n()
  )

edta_ltr_identity_summary

```


Homology vs Structure-based

```{r include=FALSE}
combined_age <- bind_rows(
  edta_homol %>%
    select(identity) %>%
    rename(value = identity) %>%
    mutate(type = "Homology-based (identity)"),
  
  edta_struct %>%
    select(ltr_identity) %>%
    rename(value = ltr_identity) %>%
    mutate(type = "Structure-based LTR (ltr_identity)")
)

```

```{r}
ggplot(combined_age, aes(x = value, fill = type)) +
  geom_histogram(alpha = 0.6, bins = 50, position = "identity") +
  labs(
    title = "EDTA – Comparison of TE Age Metrics",
    x = "Age Proxy (Identity or LTR–LTR Identity)",
    y = "Count",
    fill = "Detection Method"
  ) +
  theme_bw()

```

```{r}
ggplot(combined_age, aes(x = type, y = value, fill = type)) +
  geom_boxplot() +
  coord_flip() +
  labs(
    title = "EDTA – TE Age Comparison: Homology vs Structural LTRs",
    x = "Detection Method",
    y = "Age Proxy Value"
  ) +
  theme_bw()

```

**Earl Grey**

KIMURA80 is a divergence-based age estimate that measures how many mutations have accumulated in a TE copy relative to its consensus sequence.
Low KIMURA80 values indicate recently inserted, young elements, whereas high values reflect older, more degraded TE copies that have experienced extensive substitutions over evolutionary time.

```{r echo=FALSE}
ggplot(earl2, aes(x = KIMURA80)) +
  geom_histogram(bins = 50, fill = "darkorange", color = "black") +
  labs(
    title = "Earl Grey – KIMURA80 Divergence Distribution",
    x = "KIMURA80 (Sequence Divergence)",
    y = "Count"
  ) +
  theme_bw()

```

```{r echo=FALSE}
ggplot(earl2, aes(x = class, y = KIMURA80, fill = class)) +
  geom_boxplot() +
  coord_flip() +
  labs(
    title = "Earl Grey – KIMURA80 by TE Class",
    x = "Class",
    y = "KIMURA80 Divergence"
  ) +
  theme_bw()

```

```{r echo=FALSE}
earl_k80_by_class <- earl2 %>%
  group_by(class) %>%
  summarise(
    n = n(),
    mean_k80 = mean(KIMURA80, na.rm = TRUE),
    median_k80 = median(KIMURA80, na.rm = TRUE),
    sd_k80 = sd(KIMURA80, na.rm = TRUE)
  )

earl_k80_by_class

```

```{r echo=FALSE}
ggplot(earl2, aes(x = order, y = KIMURA80, fill = order)) +
  geom_boxplot() +
  coord_flip() +
  labs(
    title = "Earl Grey – KIMURA80 by TE Order",
    x = "Order",
    y = "KIMURA80 Divergence"
  ) +
  theme_bw() +
  theme(legend.position = "none")
```


```{r echo=FALSE}

earl_k80_by_order <- earl2 %>%
  group_by(order) %>%
  summarise(
    n = n(),
    mean_k80 = mean(KIMURA80, na.rm = TRUE),
    median_k80 = median(KIMURA80, na.rm = TRUE),
    sd_k80 = sd(KIMURA80, na.rm = TRUE)
  )

earl_k80_by_order

```
```{r echo=FALSE}
combined_age_eg_edta <- bind_rows(
  edta_homol %>%
    select(identity) %>%
    rename(value = identity) %>%
    mutate(metric = "EDTA_identity"),
  
  earl2 %>%
    select(KIMURA80) %>%
    rename(value = KIMURA80) %>%
    mutate(metric = "EarlGrey_KIMURA80")
)

ggplot(combined_age_eg_edta, aes(x = value, fill = metric)) +
  geom_histogram(alpha = 0.6, bins = 60, position = "identity") +
  labs(
    title = "Comparison of TE Age Distributions (EDTA vs Earl Grey)",
    x = "Age Proxy (Identity or KIMURA80)",
    y = "Count",
    fill = "Dataset"
  ) +
  theme_bw()

```


### EDTA method-of-identification statistics

```{r echo=FALSE}

edta_method_stats <- edta2 %>%
  count(method, sort = TRUE) %>%
  mutate(prop = round(n / sum(n), 4))

kable(edta_method_stats,
      caption = "EDTA: TE Counts by Identification Method",
      align = "lrr") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped", "hover"))

```

```{r echo=FALSE}
ggplot(edta_method_stats,
       aes(x = fct_reorder(method, n), y = n, fill = method)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "EDTA – TE Count by Identification Method",
    x = "Method",
    y = "TE Count"
  ) +
  theme_bw()

```
```{r}
edta_method_class <- edta2 %>%
  count(method, class, sort = TRUE) %>%
  group_by(method) %>%
  mutate(prop = n / sum(n))

kable(edta_method_class,
      caption = "EDTA: Method × Class Summary",
      align = "lrrr") %>%
  kable_styling(full_width = FALSE)

```


```{r}
ggplot(edta_method_class, aes(x = method, y = n, fill = class)) +
  geom_col(position = "fill") +
  labs(
    title = "EDTA – Proportion of Classes per Identification Method",
    x = "Method",
    y = "Proportion",
    fill = "Class"
  ) +
  theme_bw()

```

```{r}
edta_method_order <- edta2 %>%
  count(method, order, sort = TRUE) %>%
  group_by(method) %>%
  mutate(prop = n / sum(n))

kable(edta_method_order,
      caption = "EDTA: Method × Order Summary",
      align = "lrrr") %>%
  kable_styling(full_width = FALSE)

```
```{r}
ggplot(edta_method_order, aes(x = method, y = n, fill = order)) +
  geom_col() +
  labs(
    x = "Method",
    y = "Count",
    fill = "Order"
  ) +
  theme_bw()

```

### Genome Coverage Analyis

```{r echo=FALSE}
edta_total_bp <- sum(edta2$width, na.rm = TRUE)
earl_total_bp <- sum(earl2$width, na.rm = TRUE)

total_bp_table <- tibble(
  Pipeline = c("EDTA", "Earl Grey"),
  Total_BP = c(edta_total_bp, earl_total_bp)
)

summary_table <- tibble(
  Pipeline = c("EDTA", "Earl Grey"),
  TE_Count = c(nrow(edta2), nrow(earl2)),
  Total_BP = c(edta_total_bp, earl_total_bp),
  Mean_Width = c(mean(edta2$width, na.rm = TRUE),
                 mean(earl2$width, na.rm = TRUE)),
  Median_Width = c(median(edta2$width, na.rm = TRUE),
                   median(earl2$width, na.rm = TRUE))
)

kable(summary_table,
      caption = "Summary of TE Annotations for EDTA and Earl Grey",
      align = "lrrrr") %>%
  kable_styling(full_width = FALSE,
                bootstrap_options = c("striped", "hover"))

```


```{r}
edta_cov_class <- edta2 %>%
  group_by(class) %>%
  summarise(total_bp = sum(width, na.rm = TRUE)) %>%
  mutate(prop = round(total_bp / sum(total_bp), 4))

earl_cov_class <- earl2 %>%
  group_by(class) %>%
  summarise(total_bp = sum(width, na.rm = TRUE)) %>%
  mutate(prop = round(total_bp / sum(total_bp), 4))

kable(edta_cov_class,
      caption = "EDTA – Genome Coverage by TE Class",
      align = "lrr") %>%
  kable_styling(full_width = FALSE)

kable(earl_cov_class,
      caption = "Earl Grey – Genome Coverage by TE Class",
      align = "lrr") %>%
  kable_styling(full_width = FALSE)

```


```{r}
edta_cov_order <- edta2 %>%
  group_by(order) %>%
  summarise(total_bp = sum(width, na.rm = TRUE)) %>%
  mutate(prop = round(total_bp / sum(total_bp), 4))

earl_cov_order <- earl2 %>%
  group_by(order) %>%
  summarise(total_bp = sum(width, na.rm = TRUE)) %>%
  mutate(prop = round(total_bp / sum(total_bp), 4))

kable(edta_cov_order,
      caption = "EDTA – Genome Coverage by TE Order",
      align = "lrr") %>%
  kable_styling(full_width = FALSE)

kable(earl_cov_order,
      caption = "Earl Grey – Genome Coverage by TE Order",
      align = "lrr") %>%
  kable_styling(full_width = FALSE)

```

```{r}
edta_cov_superfamily <- edta2 %>%
  group_by(superfamily) %>%
  summarise(total_bp = sum(width, na.rm = TRUE)) %>%
  arrange(desc(total_bp))

earl_cov_superfamily <- earl2 %>%
  group_by(superfamily) %>%
  summarise(total_bp = sum(width, na.rm = TRUE)) %>%
  arrange(desc(total_bp))

kable(edta_cov_superfamily,
      caption = "EDTA – Genome Coverage by TE Superfamily",
      align = "lr") %>%
  kable_styling(full_width = FALSE)

kable(earl_cov_superfamily,
      caption = "Earl Grey – Genome Coverage by TE Superfamily",
      align = "lr") %>%
  kable_styling(full_width = FALSE)

```

```{r include=FALSE}
edta_cov_chr <- edta2 %>%
  group_by(seqnames) %>%
  summarise(total_bp = sum(width, na.rm = TRUE)) %>%
  arrange(desc(total_bp))

earl_cov_chr <- earl2 %>%
  group_by(seqnames) %>%
  summarise(total_bp = sum(width, na.rm = TRUE)) %>%
  arrange(desc(total_bp))

kable(edta_cov_chr,
      caption = "EDTA – Genome Coverage by Chromosome",
      align = "lr") %>%
  kable_styling(full_width = FALSE)

kable(earl_cov_chr,
      caption = "Earl Grey – Genome Coverage by Chromosome",
      align = "lr") %>%
  kable_styling(full_width = FALSE)

```

```{r}
ggplot(edta_cov_class, aes(x = class, y = total_bp, fill = class)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "EDTA – Genome Coverage by TE Class",
    x = "Class",
    y = "Total bp"
  ) +
  theme_bw() +
  theme(legend.position = "none")

```


### Score Analysis

TE scores reflect local alignment quality between each TE copy and its consensus, derived from the Smith–Waterman algorithm.


High-scoring elements produce long, uninterrupted matches and are typically intact, recently inserted, or well-preserved copies.


Low-scoring elements accumulate mismatches, gaps, and truncations, reflecting older or heavily degraded TE fragments.


The strongly right-skewed score distributions arise because most genomic TE copies are ancient remnants, while only a few remain intact enough to achieve high scores.


TE score therefore serves as a proxy for TE completeness, structural integrity, and relative evolutionary age, complementing identity and divergence metrics.



```{r echo=FALSE}

ggplot(edta2, aes(x = score)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "black") +
  labs(
    title = "EDTA – TE Score Distribution",
    x = "Score",
    y = "Count"
  ) +
  theme_bw()


ggplot(earl2, aes(x = score)) +
  geom_histogram(bins = 50, fill = "darkorange", color = "black") +
  labs(
    title = "Earl Grey – TE Score Distribution",
    x = "Score",
    y = "Count"
  ) +
  theme_bw()

par(mfrow=c(1,2))

```

```{r}
ggplot(earl2, aes(x = score)) +
  geom_histogram(bins = 200, fill = "darkorange", color = "black") +
  coord_cartesian(xlim = c(20000, max(earl2$score, na.rm = TRUE))) +
  labs(
    title = "Earl Grey – TE Score Distribution (Zoomed)",
    x = "Score",
    y = "Count"
  ) +
  theme_bw()

```


```{r}
max(earl2$score)
min(earl2$score)
```

```{r}
library(patchwork)

p_edta_score <- ggplot(edta2, aes(x = log10(score + 1))) +
  geom_histogram(bins = 50, fill = "steelblue", color = "black") +
  labs(
    x = "log10(Score + 1)",
    y = "Count"
  ) +
  theme_bw()

p_earl_score <- ggplot(earl2, aes(x = log10(score + 1))) +
  geom_histogram(bins = 50, fill = "darkorange", color = "black") +
  labs(
    x = "log10(Score + 1)",
    y = "Count"
  ) +
  theme_bw()

p_edta_score | p_earl_score

```

```{r}
library(patchwork)

# Common x-axis limits
xmin <- min(c(log10(edta2$score + 1), log10(earl2$score + 1)), na.rm = TRUE)
xmax <- max(c(log10(edta2$score + 1), log10(earl2$score + 1)), na.rm = TRUE)

p_edta_score_den <- ggplot(edta2, aes(x = log10(score + 1))) +
  geom_density(fill = "steelblue", alpha = 0.35, linewidth = 1) +
  scale_x_continuous(limits = c(xmin, xmax)) +
  labs(
    x = "log10(Score + 1)",
    y = "Density"
  ) +
  theme_bw()

p_earl_score_den <- ggplot(earl2, aes(x = log10(score + 1))) +
  geom_density(fill = "darkorange", alpha = 0.35, linewidth = 1) +
  scale_x_continuous(limits = c(xmin, xmax)) +
  labs(
    x = "log10(Score + 1)",
    y = "Density"
  ) +
  theme_bw()

p_edta_score_den | p_earl_score_den

```

